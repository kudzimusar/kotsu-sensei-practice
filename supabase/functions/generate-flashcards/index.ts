import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.77.0";
import { corsHeaders } from "../_shared/cors.ts";
import { mapFlashcardCategoryToDbCategory } from "../_shared/wikimedia-image-lookup.ts";

/**
 * IMAGE-FIRST Flashcard Generation
 * 
 * This function uses verified database metadata as the source of truth.
 * Flashcards are built FROM images with their metadata, NOT generated by AI then matched to images.
 * 
 * Flow:
 * 1. Fetch verified images from road_sign_images with complete metadata
 * 2. Build flashcards using sign_name_en, sign_meaning, sign_name_jp from metadata
 * 3. Generate distractors from other signs in the same category
 * 4. Optionally use AI only to enhance question phrasing (not core content)
 */

// Category to database mapping
const CATEGORY_DB_MAP: { [key: string]: string } = {
  'regulatory-signs': 'regulatory',
  'warning-signs': 'warning',
  'indication-signs': 'indication',
  'guidance-signs': 'guidance',
  'auxiliary-signs': 'auxiliary',
  'road-markings': 'road-markings',
  'traffic-signals': 'traffic-signals',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { category, count = 10 } = await req.json();
    
    console.log(`üé¥ IMAGE-FIRST flashcard generation: category="${category}", count=${count}`);
    
    // Create Supabase client
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    
    if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
      throw new Error('Supabase credentials not configured');
    }
    
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    });
    
    // Map frontend category to database category
    const dbCategory = CATEGORY_DB_MAP[category] || mapFlashcardCategoryToDbCategory(category);
    
    if (!dbCategory) {
      throw new Error(`Invalid category: ${category}. Valid categories: ${Object.keys(CATEGORY_DB_MAP).join(', ')}`);
    }
    
    console.log(`üìÇ Database category: ${dbCategory}`);
    
    // STEP 1: Fetch verified images WITH complete metadata (IMAGE-FIRST approach)
    // Priority: images with sign_name_en AND sign_meaning populated
    const { data: verifiedImages, error: imagesError } = await supabase
      .from('road_sign_images')
      .select(`
        id,
        storage_url,
        file_name,
        sign_number,
        sign_name_en,
        sign_name_jp,
        sign_meaning,
        sign_category,
        attribution_text,
        license_info,
        wikimedia_page_url,
        artist_name,
        image_source,
        metadata_hydrated
      `)
      .eq('sign_category', dbCategory)
      .eq('is_verified', true)
      .not('sign_name_en', 'is', null)
      .order('usage_count', { ascending: false, nullsFirst: false })
      .limit(count * 2); // Get more than needed for randomization
    
    if (imagesError) {
      console.error('Error fetching images:', imagesError);
      throw new Error(`Failed to fetch images: ${imagesError.message}`);
    }
    
    if (!verifiedImages || verifiedImages.length === 0) {
      console.log(`‚ö†Ô∏è No verified images found for category ${dbCategory}, trying without sign_name_en filter`);
      
      // Fallback: get any verified images in this category
      const { data: fallbackImages, error: fallbackError } = await supabase
        .from('road_sign_images')
        .select(`
          id,
          storage_url,
          file_name,
          sign_number,
          sign_name_en,
          sign_name_jp,
          sign_meaning,
          sign_category,
          attribution_text,
          license_info,
          wikimedia_page_url,
          artist_name,
          image_source,
          metadata_hydrated
        `)
        .eq('sign_category', dbCategory)
        .eq('is_verified', true)
        .order('usage_count', { ascending: false, nullsFirst: false })
        .limit(count * 2);
      
      if (fallbackError || !fallbackImages || fallbackImages.length === 0) {
        throw new Error(`No images found for category: ${dbCategory}`);
      }
      
      // Use fallback images
      console.log(`üì¶ Using ${fallbackImages.length} fallback images`);
    }
    
    const images = verifiedImages && verifiedImages.length > 0 ? verifiedImages : [];
    
    // Shuffle and select requested count
    const shuffledImages = images
      .sort(() => Math.random() - 0.5)
      .slice(0, count);
    
    console.log(`üì∏ Selected ${shuffledImages.length} images for flashcards`);
    
    // STEP 2: Fetch distractors (other signs from same category for wrong answers)
    const { data: allCategorySigns, error: distractorError } = await supabase
      .from('road_sign_images')
      .select('sign_name_en, sign_name_jp, sign_category')
      .eq('sign_category', dbCategory)
      .eq('is_verified', true)
      .not('sign_name_en', 'is', null)
      .limit(100);
    
    const distractorPool = allCategorySigns || [];
    console.log(`üéØ Distractor pool: ${distractorPool.length} signs`);
    
    // STEP 3: Build flashcards FROM image metadata (NOT from AI)
    const flashcards = shuffledImages.map((image: any, index: number) => {
      // Get sign name - use metadata, or derive from filename as last resort
      const signNameEn = image.sign_name_en || 
        image.file_name?.replace(/[-_]/g, ' ').replace(/\.svg|\.png|\.jpg/gi, '').trim() ||
        'Unknown Sign';
      
      const signNameJp = image.sign_name_jp || null;
      
      // Get sign meaning/explanation from metadata
      const explanation = image.sign_meaning || 
        `This is a ${image.sign_category || 'road'} sign. Study this sign for your driving test.`;
      
      // Generate question (simple, clear)
      const question = "What does this road sign indicate?";
      
      // Correct answer comes directly from database metadata
      const correctAnswer = signNameEn;
      
      // Generate distractors (wrong answers) from same category
      const otherSigns = distractorPool
        .filter((d: any) => d.sign_name_en && d.sign_name_en !== signNameEn)
        .map((d: any) => d.sign_name_en);
      
      // Shuffle and pick 3 distractors
      const shuffledDistractors = otherSigns
        .sort(() => Math.random() - 0.5)
        .slice(0, 3);
      
      // Build options array (correct answer + 3 distractors)
      const options = [correctAnswer, ...shuffledDistractors]
        .filter((v, i, a) => a.indexOf(v) === i) // Remove duplicates
        .sort(() => Math.random() - 0.5); // Shuffle
      
      // Ensure correct answer is in options
      if (!options.includes(correctAnswer)) {
        options[0] = correctAnswer;
      }
      
      console.log(`‚úÖ Flashcard ${index + 1}: "${signNameEn}" - ${options.length} options`);
      
      return {
        // Core flashcard data
        question,
        answer: correctAnswer,
        correct_answer: correctAnswer,
        explanation,
        options: options.slice(0, 4), // Max 4 options
        difficulty: 'easy',
        
        // Image data from database
        imageUrl: image.storage_url,
        imageQuery: signNameEn, // For compatibility
        roadSignImageId: image.id,
        
        // Sign metadata
        signNameEn,
        signNameJp,
        signNumber: image.sign_number || null,
        signCategory: image.sign_category,
        
        // Attribution (for Wikimedia Commons)
        attributionText: image.attribution_text || null,
        licenseInfo: image.license_info || null,
        wikimediaPageUrl: image.wikimedia_page_url || null,
        artistName: image.artist_name || null,
        imageSource: image.image_source || null,
        metadataHydrated: image.metadata_hydrated || false,
      };
    });
    
    console.log(`üéâ Generated ${flashcards.length} IMAGE-FIRST flashcards`);
    
    // Update usage count for used images (best effort, ignore errors)
    try {
      const imageIds = shuffledImages.map((img: any) => img.id);
      for (const imgId of imageIds) {
        await supabase.rpc('increment_image_usage', { image_id: imgId });
      }
    } catch (e) {
      console.log('Note: Could not update usage counts');
    }
    
    return new Response(
      JSON.stringify({
        flashcards,
        count: flashcards.length,
        category,
        dbCategory,
        source: 'image-first-metadata',
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
    
  } catch (error) {
    console.error("‚ùå Error generating flashcards:", error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : "Unknown error",
        flashcards: [],
        count: 0,
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});
